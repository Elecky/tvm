# data configs
dtype_w: int16
dtype_n: int8

# scalar register file configs
register_file:
  size: 32  # number of architectural registers.
  read_port_num: 6  # number of future file read ports, can be no less than 6,
                    # since some insn has to read 6 reigsters.
  read_port_group_size: 2  # the number of read port comsumed by a insn is K times of this value.

# predict a branch is taken or just fall through.
# if false, IF will continue fetching next insn, and wait for branch request.
# if true, IF will jump to target and continue fetching, so if branch is not taken,
# the issue queue will be cleared and fetch insn starts from next insn.
predictBranchTaken: false

issue_queue:
  size: 8  # number of issue queue slots
  issue_depth: 1  # how many insns can be fetched and issued on every cycle.

rob:
  size: 16  # number of reorder buffer slots

ReservationStations:
  ALU: 8

# dram configs
dram:
  nchannel: 2
  #unit_bits: 32  # the addressable bits
  # width in bits of every channel, has to be the power of 2
  width_per_channel: 64
  # log size in byte of every channel
  # due to the limit of tvm, the size is represented by int.
  log_size_per_channel: 26
  # memory address map policy
  map_policy: interleaved
  # timing related parameters
  speed: 32


# scratchpad design, choices are [unified, seperated]
scratchpad_design: unified

# unified scratchpad configs
scratchpad:
  nchannel: 4
  # qeuivalent width in bits of every channel, has to be the power of 2
  width_per_channel: 128
  # log size in byte of every channel
  log_size_per_channel: 20
  # read and write delays in cycle
  r_delay: 2
  w_delay: 2
  # memory address map policy
  map_policy: interleaved

acc_buffer:
  nchannel: 4
  # qeuivalent width in bits of every channel, has to be the power of 2
  width_per_channel: 128
  # log size in byte of every channel
  log_size_per_channel: 11
  # read and write delays in cycle
  r_delay: 1
  w_delay: 1
  # memory address map policy
  map_policy: interleaved

sclr_buffer:
  r_delay: 2
  w_delay: 2
  log_size: 12  # 4KB scalar buffer.

vctr_scratchpad: {}
mat_scratchpad: {}

vector_unit:
  size: 16

matrix_unit:
  set_up_cycle: false  # need one cycle to calculate and set up read/write access.
                      # this simply adds one cycle on every instruction's read/write phase.

DMA:
  start_up_time: 5  # the time in cycles needed to start a DMA.
  speed: 16  # the qeuivalent transfer speed, bytes per cycle (of accelerator).

delay_modeling_switch:
  DMA: true
  scratchpad_ls: true