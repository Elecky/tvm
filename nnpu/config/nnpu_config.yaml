# data configs
dtype_w: int16
dtype_n: int8

# scalar register file configs
# number of register file elements
register_file_size: 32

# predict a branch is taken or just fall through.
# if false, IF will continue fetching next insn, and wait for branch request.
# if true, IF will jump to target and continue fetching, so if branch is not taken,
# the issue queue will be cleared and fetch insn starts from next insn.
predictBranchTaken: false

# dram configs
dram:
  nchannel: 2
  #unit_bits: 32  # the addressable bits
  # width in bits of every channel, has to be the power of 2
  width_per_channel: 64
  # log size in byte of every channel
  # due to the limit of tvm, the size is represented by int.
  log_size_per_channel: 26
  # memory address map policy
  map_policy: interleaved
  # timing related parameters


# scratchpad design, choices are [unified, seperated]
scratchpad_design: unified

# unified scratchpad configs
scratchpad:
  nchannel: 2
  # width in bits of every channel, has to be the power of 2
  width_per_channel: 128
  # log size in byte of every channel
  log_size_per_channel: 20
  # read and write delays in cycle
  r_delay: 2
  w_delay: 2
  # memory address map policy
  map_policy: interleaved

acc_buffer:
  nchannel: 2
  # width in bits of every channel, has to be the power of 2
  width_per_channel: 128
  # log size in byte of every channel
  log_size_per_channel: 12
  # read and write delays in cycle
  r_delay: 1
  w_delay: 1
  # memory address map policy
  map_policy: interleaved

vctr_scratchpad: {}
mat_scratchpad: {}

vector_unit:
  size: 16